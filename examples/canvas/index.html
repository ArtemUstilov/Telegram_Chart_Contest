<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Page Title</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="/dist/bundle.js"></script>
    <link rel="stylesheet" type="text/css" href="canvas.css">
</head>
<body>
<div class="container">
    <canvas id="canvas" width="500" height="500"></canvas>
    <div class="preview-wrap">
        <canvas id="preview" width="500" height="50"></canvas>
        <div id="bg-preview"></div>
        <div id="bg-preview-active"></div>
        <div id="marker" class="marker"></div>
        <div id="dragCircle"></div>
    </div>
</div>
<script>
  let data;
  fetch('/data/chart_data.json')
    .then(res => res.json())
    .then(res => {
      data = format(res[0]);
      run(data);
    })
    .catch(err => console.log(err));

  function format(data) {
    return ({
      lines: data.columns.filter(col => data.types[col[0]] === 'line').map(line => ({
        values: line.slice(1),
        color: data.colors[line[0]],
        name: data.names[line[0]],
      })),
      x: data.columns.find(col => data.types[col[0]] === 'x').slice(1),
    })
  }

  function run(data) {
    let element = document.getElementById('canvas');
    let preview = document.getElementById('preview');
    const canvasGraph = graph.createCanvasGraph(element);
    const previewGraph = graph.createCanvasGraph(preview);
    const minX = Math.min(...data.x);
    const maxX = Math.max(...data.x);
    const minY = Math.min(...data.lines[0].values, ...data.lines[1].values);
    const maxY = Math.max(...data.lines[0].values, ...data.lines[1].values);
    const scale = { minX, maxX, minY, maxY };
    //const scale2 = { minX: 3, maxX: 6, minY: 1, maxY: 6 };
    canvasGraph.setData(data);
    canvasGraph.setScale(scale);
    canvasGraph.refresh();
    previewGraph.setData(data);
    previewGraph.setScale(scale);
    previewGraph.refresh();
    let el = document.getElementById('marker');

    dragMaster.makeDraggable(el,
      element.getBoundingClientRect().left, element.offsetWidth,
      8, document.getElementById('bg-preview-active'),
        document.getElementById('dragCircle'), 70);
  }


  const dragMaster = (function () {
    let dragObject;
    let mouseOffset;
    let leftEdge;
    let rightEdge;
    let mWidth;
    let offsetWidth;
    let clientWidth;
    let dragObjWidth;
    let bgElem;
    let dragCirc;
    let circleSize;
    function getMouseOffset(target, e) {
      const docPos = { x: target.offsetLeft, y: target.offsetTop };
      return { x: e.pageX - docPos.x, y: e.pageY - docPos.y }
    }

    function mouseUp() {
      dragObject = null;
      dragCirc.style.width = '0';
      dragCirc.style.height = '0';
      dragCirc.style.transform = 'translateY(35px) translateX(35px)';
      document.onmousemove = null;
      document.onmouseup = null;
      // document.ontouchstart = null;
      // document.ontouchend = null;
      // document.ontouchmove = null;
      document.ondragstart = null;
      document.body.onselectstart = null
    }
    const dragCircleRightUpd = (width) => dragCirc.style.left = (dragObject.offsetLeft + width - circleSize/2 + mWidth*3/2) + 'px';
    const dragCircleLeftUpd = (left) => dragCirc.style.left = (left - circleSize/2 + mWidth/2) + 'px';
    const dragCircleMoveUpd = (d) => dragCirc.style.left = (d + dragObject.offsetWidth/2 - circleSize/2) + 'px';

    function stretchRight(e) {
      let width = e.pageX - dragObject.offsetLeft - leftEdge;
      if (dragObject.offsetLeft + width > clientWidth) {
        width = clientWidth - dragObject.offsetLeft;
      }
      width = width < 0 ? 0 : width;
      updatePos(width);
      dragCircleRightUpd(width);
    }
    function updatePos(width, left){
      if(width !== undefined) {
        dragObject.style.width = width + 'px';
        if (bgElem)
          bgElem.style.width = width + mWidth + 'px';
      }
      if(left !== undefined){
        dragObject.style.left = left + 'px';
        if (bgElem)
          bgElem.style.left = left + 'px';
      }
    }
    function stretchLeft(e) {
        let left = e.pageX - leftEdge < 0 ? 0 : e.pageX - leftEdge;
        let width = dragObject.offsetLeft + dragObject.clientWidth - left;
        if(width < 1) {
          width = 0;
          left = dragObject.offsetLeft+dragObject.offsetWidth - mWidth*2;
        }
        updatePos(width, left);
        dragCircleLeftUpd(left);
    }

    function mouseMove(e) {
      let d = e.pageX - mouseOffset.x;
      let r = offsetWidth - dragObject.offsetWidth;
      d = d < 0 ? 0 : d;
      d = d > r ? r : d;

      updatePos(undefined, d);
      dragCircleMoveUpd(d);
    }

    function mouseDown(e) {
      if (e.which !== 1) return;
      dragObject = this;
      dragCirc.style.width = '70px';
      dragCirc.style.height = '70px';
      dragCirc.style.transform = 'translateY(0) translateX(0)';
      // dragCirc.style.top = '-10px';
      mouseOffset = getMouseOffset(this, e);
      dragObjWidth = dragObject.clientWidth;
      const x = e.offsetX;
      if (x > dragObject.clientWidth) {
        document.onmousemove = stretchRight;
        // document.ontouchmove = stretchRight;
        dragCircleRightUpd(dragObject.clientWidth);
      }else if (x < 0) {
        document.onmousemove = stretchLeft;
        // document.ontouchmove = stretchLeft;
        dragCircleLeftUpd(dragObject.offsetLeft);
      }else {
        document.onmousemove = mouseMove;
        // document.ontouchmove = mouseMove;
        dragCircleMoveUpd(dragObject.offsetLeft);
      }
      document.onmouseup = mouseUp;
      // document.ontouchend = mouseUp;
      document.ondragstart = function () {
      };
      document.body.onselectstart = function () {
      };
    }

    return {
      makeDraggable: function (element, left, width, markersWidth, bgEl, dragCircle, size) {
        // TODO add touch handling
        element.onmousedown = mouseDown;
        // element.ontouchstart = mouseDown;
        leftEdge = left;
        rightEdge = left + width;
        mWidth = markersWidth;
        offsetWidth = width;
        bgElem = bgEl
        clientWidth = offsetWidth - mWidth * 2;
        dragCirc = dragCircle;
        circleSize = size;
      }
    }
  })();
</script>
</body>
</html>
