<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Page Title</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="/bundle.js"></script>
    <script src="/test/random.js"></script>
</head>
<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    html,
    body {
        width: 100%;
        height: 100%;
    }

    body {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
    }

    #graph {
        background-color: #eeeeee;
        width: 500px;
        height: 500px;
    }
</style>

<body>
    <div id="graph"></div>
    <div class="buttons">
        <button id="random">RANDOM SHOW</button>
        <button id="tg-data">TELEGRAM DATA</button>
    </div>
    <script>
        const MIN = 0;
        const MAX = 100;
        const COUNT = 100;
        const POINTS = 1000000;
        const RENDER_RAW_MAX = 100000;
        const LINES = 3;
        const element = document.getElementById('graph');
        const myGraph = graph.createSVGGraph(element);
        const timeout = time => new Promise(resolve => setTimeout(resolve, time));
        const SIMPLIFY_RATES = [8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024];
        const RANDOM_COUNT = [10, 100, 1000, 10000, 100000, 1000000];
        const getScaleFromItem = (item) => {
            const minX = Math.min.apply(Math, item.x);
            const maxX = Math.max.apply(Math, item.x);
            const minY = Math.min.apply(Math, item.lines.map(line => Math.min.apply(Math, line.values)));
            const maxY = Math.max.apply(Math, item.lines.map(line => Math.max.apply(Math, line.values)));
            return { minX, maxX, minY, maxY };
        };

        const preview = async (rawItem) => {
            for (let rate of SIMPLIFY_RATES) {
                if (rawItem.x.length < rate) break;
                let start = Date.now();
                let item;
                for (let i = 0; i < COUNT; i++) {
                    item = graph.reduceGraph(rawItem, rate);
                }
                console.log('RATE', rate, 'POINTS', rawItem.x.length, 'LINES', rawItem.lines.length, 'OPTIMIZED', item.x.length);
                console.log('OPTIMIZED', (Date.now() - start) / COUNT, 'ms');
                if (rawItem.x.length <= RENDER_RAW_MAX) {
                    myGraph.setData(rawItem);
                    myGraph.setScale(getScaleFromItem(rawItem));
                    start = Date.now();
                    myGraph.refresh();
                    console.log('RAW RENDERED', Date.now() - start, 'ms');
                } else {
                    console.log('Too many points, skipping raw render');
                }
                myGraph.setData(item);
                myGraph.setScale(getScaleFromItem(item));
                start = Date.now();
                for (let i = 0; i < COUNT; i++) {
                    myGraph.refresh();
                }
                console.log('RENDERED', (Date.now() - start) / COUNT, 'ms');
                await timeout(2000);
            }
        };

        const randomData = async () => {
            const data = await fetch('/data/chart_data.json');
            const dataJson = await data.json();
            const formattedData = dataJson.map(graph.format);
            for (let pointsCount of RANDOM_COUNT) {
                const rawItem = generateRandomGraph(MIN, MAX, LINES, pointsCount);
                await preview(rawItem);
            }
        };

        const telegramData = async () => {
            const data = await fetch('/data/chart_data.json');
            const dataJson = await data.json();
            const formattedData = dataJson.map(graph.format);
            for (let rawItem of formattedData) {
                await preview(rawItem);
            }
        };
        document.getElementById('random').addEventListener('click', () => randomData().then());
        document.getElementById('tg-data').addEventListener('click', () => telegramData().then());
    </script>
</body>

</html>